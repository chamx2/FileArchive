/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package SubProb;

import java.awt.Color;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.text.DecimalFormat;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;

/**
 *
 * @author aris
 */
public class SubProb extends javax.swing.JFrame {
    private JTextField[][] Matrix;
    int view=0,mrows=0,mcolumns=0;
    boolean allow=false;
    int[] FA;
    int[] FA2;
    /**
     * Creates new form SimplexAlgorithm
     */
    public SubProb() {
        initComponents();
        this.setSize(1000,600);
        this.setLocation(180,40);
        compute.setEnabled(false);
        this.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("icon.png")));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mainframe = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        ct = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        bi = new javax.swing.JTextField();
        generate = new javax.swing.JButton();
        scroller = new javax.swing.JScrollPane();
        tableau = new javax.swing.JPanel();
        jScrollPane = new javax.swing.JScrollPane();
        computation = new javax.swing.JPanel();
        clear = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        compute = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Subproblem");
        setResizable(false);
        getContentPane().setLayout(new java.awt.GridLayout(1, 0));

        mainframe.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jLabel1.setFont(new java.awt.Font("DJB CHALK IT UP", 0, 18)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(255, 255, 255));
        jLabel1.setText("No. of Column CTx:");
        mainframe.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(270, 60, 170, 30));
        mainframe.add(ct, new org.netbeans.lib.awtextra.AbsoluteConstraints(440, 60, 40, 30));

        jLabel2.setFont(new java.awt.Font("DJB CHALK IT UP", 0, 18)); // NOI18N
        jLabel2.setForeground(new java.awt.Color(255, 255, 255));
        jLabel2.setText(" No. of Row bi:");
        mainframe.add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(490, 60, 130, 30));
        mainframe.add(bi, new org.netbeans.lib.awtextra.AbsoluteConstraints(630, 60, 40, 30));

        generate.setFont(new java.awt.Font("DJB CHALK IT UP", 1, 12)); // NOI18N
        generate.setText("GENERATE TABLE");
        generate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generateActionPerformed(evt);
            }
        });
        mainframe.add(generate, new org.netbeans.lib.awtextra.AbsoluteConstraints(690, 60, -1, 30));

        scroller.setBorder(javax.swing.BorderFactory.createMatteBorder(2, 2, 2, 2, new java.awt.Color(0, 0, 0)));

        tableau.setLayout(new java.awt.GridLayout(1, 0));
        scroller.setViewportView(tableau);

        mainframe.add(scroller, new org.netbeans.lib.awtextra.AbsoluteConstraints(50, 130, 470, 380));

        jScrollPane.setBorder(javax.swing.BorderFactory.createMatteBorder(2, 2, 2, 2, new java.awt.Color(0, 0, 0)));

        computation.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
        jScrollPane.setViewportView(computation);

        mainframe.add(jScrollPane, new org.netbeans.lib.awtextra.AbsoluteConstraints(580, 130, 360, 380));

        clear.setFont(new java.awt.Font("DJB CHALK IT UP", 1, 12)); // NOI18N
        clear.setText("CLEAR");
        clear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearActionPerformed(evt);
            }
        });
        mainframe.add(clear, new org.netbeans.lib.awtextra.AbsoluteConstraints(70, 520, 130, 30));

        jLabel3.setFont(new java.awt.Font("DJB CHALK IT UP", 1, 36)); // NOI18N
        jLabel3.setForeground(new java.awt.Color(255, 255, 255));
        jLabel3.setText("Solution");
        mainframe.add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(700, 100, 140, 30));

        compute.setFont(new java.awt.Font("DJB CHALK IT UP", 1, 12)); // NOI18N
        compute.setText("Solver for Canonical Form ");
        compute.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                computeActionPerformed(evt);
            }
        });
        mainframe.add(compute, new org.netbeans.lib.awtextra.AbsoluteConstraints(220, 520, 220, 30));

        jLabel4.setFont(new java.awt.Font("DJB CHALK IT UP", 1, 36)); // NOI18N
        jLabel4.setForeground(new java.awt.Color(255, 255, 255));
        jLabel4.setText("Tableau");
        mainframe.add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(210, 90, 130, -1));

        jLabel5.setFont(new java.awt.Font("DJB CHALK IT UP", 0, 42)); // NOI18N
        jLabel5.setForeground(new java.awt.Color(255, 255, 255));
        jLabel5.setText("Subproblem Technique");
        mainframe.add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(310, 20, 380, 40));

        jLabel6.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel6.setIcon(new javax.swing.ImageIcon(getClass().getResource("/SubProb/bg.jpg"))); // NOI18N
        mainframe.add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, -1, -1));

        getContentPane().add(mainframe);
        mainframe.getAccessibleContext().setAccessibleName("");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void generateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateActionPerformed
        
        // TODO add your handling code here:
        if(ct.getText().equals("") || bi.getText().equals("")){
            JOptionPane.showMessageDialog(null,"Inputs must have a value!!!.","ERROR",JOptionPane.ERROR_MESSAGE);
            ct.setText("");
            bi.setText("");
            mrows=mcolumns=0;
            mainframe.setVisible(false);
            mainframe.setVisible(true);
        }
        else{
        //Remove past matrix
        for(int column=0;column<mcolumns;column++){
            for(int row=0;row<mrows;row++){
                tableau.remove(Matrix[column][row]);
            }
        }
        //Initialize new matrix
        mrows=Integer.parseInt(ct.getText())+1;
        mcolumns=Integer.parseInt(bi.getText())+1;
        if(mrows>3 && mcolumns>3){
            
            //MATRIX-make textfields
            tableau.setLayout(new java.awt.GridLayout(mcolumns, mrows));
            Matrix=new JTextField[mcolumns][mrows];
            compute.setEnabled(true);
            for(int column=0 ;column<mcolumns;column++){
                for(int row=0;row<mrows;row++){ 
                    Matrix[column][row]=new JTextField();
                    Matrix[column][row].setText("0");
                    if(column==0 && row==0){
                        Matrix[column][row].setBorder(BorderFactory.createMatteBorder(0,0,1,1,Color.black));
                    }else if(column==0){
                        Matrix[column][row].setBorder(BorderFactory.createMatteBorder(0,0,1,0,Color.black));
                    }else if(row==0){
                        Matrix[column][row].setBorder(BorderFactory.createMatteBorder(0,0,0,1,Color.black));
                    }else{
                        Matrix[column][row].setBorder(null);
                    }
                    Matrix[column][row].setText("0");
                    Matrix[column][row].setVisible(true);
                    Matrix[column][row].setColumns(5);
                    Matrix[column][row].setHorizontalAlignment(javax.swing.JTextField.CENTER);  
                    tableau.add(Matrix[column][row]);
                }
            }
            
            getContentPane().setVisible(false);
            getContentPane().setVisible(true);
            ct.setEnabled(false);
            bi.setEnabled(false);
            generate.setEnabled(false);
        }else{
            JOptionPane.showMessageDialog(null,"Inputs must be equal or greater than 3!!!.","ERROR",JOptionPane.ERROR_MESSAGE);
            mrows=mcolumns=0;
            mainframe.setVisible(false);
            mainframe.setVisible(true);
        }
        }
    }//GEN-LAST:event_generateActionPerformed

    private void clearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearActionPerformed
        // TODO add your handling code here:
        tableau.removeAll();
        computation.removeAll();
        ct.setText("");
        bi.setText("");
        ct.setEnabled(true);
        bi.setEnabled(true);
        generate.setEnabled(true);
        mrows=mcolumns=0;
        mainframe.setVisible(false);
        mainframe.setVisible(true);
        compute.setEnabled(false);
    }//GEN-LAST:event_clearActionPerformed

    private void computeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_computeActionPerformed
        // TODO add your handling code here:
        compute.setEnabled(false);
        float[][] matrix=new float[mcolumns][mrows];
        FA = new int[mcolumns-1];
        FA2 = new int[mcolumns-1];
        //jTextArea.setText("");
        for(int column=0 ;column<mcolumns;column++){
            for(int row=0;row<mrows;row++){ 
                matrix[column][row]=Float.parseFloat(Matrix[column][row].getText());   
            }
        }
        
        if(checkcanonical(matrix)==true && checkoptimal(matrix)==true){
            JOptionPane.showMessageDialog(null, "The Tableau is already in its Optimal Form.");
            displayFA(matrix);
        }else if(checkinfeasibility1(matrix)==true){
            JOptionPane.showMessageDialog(null, "The Tableau is Infeasible.");
        }else if(checkinfeasibility2(matrix)==true){
            JOptionPane.showMessageDialog(null, "The Tableau is Infeasible.");
        }else if(checkunbounded(matrix)==true){
            JOptionPane.showMessageDialog(null, "The Tableau is Unbounded.");
            displayFA(matrix);
        }else if(checkcanonical(matrix)==true){
            JOptionPane.showMessageDialog(null, "The Tableau is already in its Canonical Form.");
            displayFA(matrix);
        }else{
            if(checknobasic(matrix)==false){
                JOptionPane.showMessageDialog(null, "The Tableau has no identity columns.");
                displayFA(matrix);
            }else{
                /*Initialize*/
                mainframe.remove(computation);
                mainframe.remove(jScrollPane);
                computation=new JPanel();
                jScrollPane=new JScrollPane();
                jScrollPane.setBorder(javax.swing.BorderFactory.createMatteBorder(2, 2, 2, 2, new java.awt.Color(0, 0, 0)));

                computation.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
                jScrollPane.setViewportView(computation);

                mainframe.add(jScrollPane, new org.netbeans.lib.awtextra.AbsoluteConstraints(580, 130, 360, 380));
                view=0;
                /*Start solving*/
                /*Sorting the rows from most negative*/
                for(int column=1;column<mcolumns;column++){
                    int mostnegative=column;
                    //Step 1: Finding the most negative
                    for(int column2=column;column2<mcolumns;column2++){
                        if(matrix[mostnegative][0]>matrix[column2][0]){
                            mostnegative=column2;
                        }
                    }
                    //Step 2: Check if it needs switching
                    if(mostnegative!=column){
                        //Step 3: Make switch
                        float temp;
                        for(int row=0;row<mrows;row++){
                            temp=matrix[mostnegative][row];
                            matrix[mostnegative][row]=matrix[column][row];
                            matrix[column][row]=temp;
                        }
                    }
                        
                }
                display(matrix);
                //Check if all b's are negative
                int negacheck=0;
                for(int column=1;column<mcolumns;column++){
                    if(matrix[column][0]<0){
                        negacheck++;
                    }
                }
                if(negacheck==mcolumns-1){
                    //Multiply whole row by -1
                    for(int row=0;row<mrows;row++){
                        matrix[mcolumns-1][row]*=-1;
                    }
                    display(matrix);
                }
                while(checkcanonical(matrix)==false){
                    //Finding the bottommost negative
                    int subcolumn=0;
                    for(int column=mcolumns-1;column>=1;column--){
                        if(matrix[column][0]<0){
                            subcolumn=column;
                            break;
                        }
                    }
                    displaysub(matrix,subcolumn);
                    //Finding the negative smallest index
                    int pivotrow=1;
                    int nonegativechecker=0;
                    for(int row=1;row<mrows;row++){
                        if(matrix[subcolumn][row]<0){
                            pivotrow=row;
                            break;
                        }else{
                            nonegativechecker++;
                        }
                    }
                    if(nonegativechecker==mrows-1){
                        //Multiply row by -1
                        for(int row=0;row<mrows;row++){
                            matrix[subcolumn][row]*=-1;
                        }
                        display(matrix);
                    }
                    else{
                        //Finding the lowest positive ratio under subcolumn*/
                        int pivotcolumn=subcolumn+1;
                        int tempcolumn=subcolumn+1;
                        float lowestRatio=matrix[tempcolumn][0]/matrix[tempcolumn][pivotrow];
                        while(lowestRatio<=0 && tempcolumn+1<mcolumns){
                            tempcolumn++;
                            pivotcolumn++;
                            lowestRatio=matrix[tempcolumn][0]/matrix[tempcolumn][pivotrow];
                        }
                        if(lowestRatio<=0){
                            JOptionPane.showMessageDialog(null, "The tableau is unbounded.");
                            displayFA(matrix);
                            break;
                        }else{
                            for(int column=tempcolumn+1;column<mcolumns;column++){
                                if(matrix[column][0]/matrix[column][pivotrow]<lowestRatio && matrix[column][pivotrow]>0){
                                    lowestRatio=matrix[column][0]/matrix[column][pivotrow];
                                    pivotcolumn=column;
                                }
                            }
                            displaydivide(matrix, pivotcolumn, pivotrow);
                            displaysub(matrix,subcolumn,pivotcolumn,pivotrow);
                            /*Divide row by pivot*/
                            float divider=matrix[pivotcolumn][pivotrow];
                            for(int row=0;row<mrows;row++){
                                matrix[pivotcolumn][row]=matrix[pivotcolumn][row]/divider;
                            }
                            displaysubtract(matrix, pivotcolumn, pivotrow);
                            displaysub(matrix,subcolumn);
                            /*Sweep*/
                            for(int column=0;column<mcolumns;column++){
                                if(pivotcolumn!=column){
                                    float var=-matrix[column][pivotrow];
                                    for(int row=0;row<mrows;row++){
                                        matrix[column][row]=matrix[column][row]+(var*matrix[pivotcolumn][row]);
                                    }
                                }
                            }
                            displaysub(matrix,subcolumn);
                            if(checkcanonical(matrix)==true && checkoptimal(matrix)==true){
                                JOptionPane.showMessageDialog(null, "The tableau is optimal.");
                                displayFA(matrix);
                                break;
                            }if(checkcanonical(matrix)==true){
                                JOptionPane.showMessageDialog(null, "The tableau is canonical.");
                                displayFA(matrix);
                                break;
                            }else if(checkinfeasibility1(matrix)==true){
                                JOptionPane.showMessageDialog(null, "The tableau is infeasible.");
                                break;
                            }else if(checkinfeasibility2(matrix)==true){
                                JOptionPane.showMessageDialog(null, "The tableau is infeasible.");
                                break;
                            }else if(checkcanonical(matrix) && checkunbounded(matrix)==true){
                                JOptionPane.showMessageDialog(null, "The tableau is unbounded.");
                                displayFA(matrix);
                                break;
                            }
                        }
                        
                    }
                }
                JOptionPane.showMessageDialog(null, "Done.");    
            }
            
        }
        jScrollPane.setVisible(false);
        jScrollPane.setVisible(true);
        computation.setVisible(false);
        computation.setVisible(true);
        mainframe.remove(jLabel6);
        jLabel6.setIcon(new javax.swing.ImageIcon(getClass().getResource("/SubProb/bg.jpg"))); // NOI18N
        mainframe.add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, -1, -1));
        getContentPane().setVisible(false);
        getContentPane().setVisible(true);
    }//GEN-LAST:event_computeActionPerformed
    
    public boolean checknobasic(float[][] matrix){
        String[] text=new String[mrows];
        String[] identity=new String[mcolumns-1];
        for(int column=0;column<mcolumns-1;column++){
            String text2=new String();
            text2="";
            for(int row=0;row<mcolumns-1;row++){
                if(column==row){
                    text2+=" 1.0";
                }else{
                    text2+=" 0.0";
                }
            }
            identity[column]=text2;
        }
        /*Formula for checking if canonical form*/
        int checker=0;
        for(int row=1; row<mrows;row++){
            text[row]="";
            for(int column=1;column<mcolumns;column++){
                text[row]+=" "+matrix[column][row];
            }
            for(int column=0;column<mcolumns-1;column++){
                if(identity[column].equals(text[row])){
                    FA[checker]=row;
                    FA2[checker]=column+1;
                    checker++;
                    identity[column]=" ";
                }
            }
        }
        if(checker==mcolumns-1){
            //formula for checking if leftmost side have negative numbers.
            for(int column=1;column<mcolumns;column++){
                if(matrix[column][0]<0){
                    return true;
                }
            }
            return false;
        }else{
            return false;
        }
    }
    
    public boolean checkcanonical(float[][] matrix){
        String[] text=new String[mrows];
        String[] identity=new String[mcolumns-1];
        for(int column=0;column<mcolumns-1;column++){
            String text2=new String();
            text2="";
            for(int row=0;row<mcolumns-1;row++){
                if(column==row){
                    text2+=" 1.0";
                }else{
                    text2+=" 0.0";
                }
            }
            identity[column]=text2;
        }
        /*Formula for checking if canonical form*/
        int checker=0;
        for(int row=1; row<mrows;row++){
            text[row]="";
            for(int column=1;column<mcolumns;column++){
                text[row]+=" "+matrix[column][row];
            }
            for(int column=0;column<mcolumns-1;column++){
                if(identity[column].equals(text[row])){
                    FA[checker]=row;
                    FA2[checker]=column+1;
                    checker++;
                    identity[column]=" ";
                }
            }
        }
        if(checker==mcolumns-1){
            //formula for checking if leftmost side have negative numbers.
            for(int column=1;column<mcolumns;column++){
                if(matrix[column][0]<0){
                    return false;
                }
            }
            return true;
        }else{
            return false;
        }
    }
    
    
    public boolean checkoptimal(float[][] matrix){
        for(int row=1;row<mrows;row++){
            if(matrix[0][row]<0){
                return false;
            }
        }
        return true;
    }
    
    public boolean checkunbounded(float[][] matrix){
        for(int row=1;row<mrows;row++){
            int cnt=0;
            for(int column=0;column<mcolumns;column++,cnt++){
                if(matrix[column][row]>0){
                    break;
                }
            }
            if(cnt==mcolumns){
                return true;
            }
        }
        return false;
    }
    
    public boolean checkinfeasibility1(float[][] matrix){
        for(int column=1;column<mcolumns;column++){
            int cnt=0;
            for(int row=0;row<mrows;row++,cnt++){
                if(matrix[column][row]>=0){
                    break;
                }
            }
            if(cnt==mrows){
                return true;
            }
        }
        return false;
    }
    
    public boolean checkinfeasibility2(float[][] matrix){
        for(int column=1;column<mcolumns;column++){
            int cnt=0;
            for(int row=0;row<mrows;row++,cnt++){
                if(row==0){
                    if(matrix[column][0]==0){
                        break;
                    }
                }else{
                    if(matrix[column][row]!=0){
                        break;
                    }
                }
            }
            if(cnt==mrows){
                return true;
            }
        }
        return false;
    }
    
    public void display(float[][] matrix,int pivotcolumn,int pivotrow){
        
        /*Add tableaus*/
        DecimalFormat dec=new DecimalFormat("0.00");
        JPanel tableaus=new JPanel();
        tableaus.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        
        JScrollPane scrollers=new JScrollPane();
        scrollers.setViewportView(tableaus);
        computation.add(scrollers, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, view, 302, 139));
        view+=200;
        
        /*Make textfields*/
        tableaus.setLayout(new java.awt.GridLayout(mcolumns, mrows));
        JTextField[][] matrices=new JTextField[mcolumns][mrows];
        
        for(int column=0 ;column<mcolumns;column++){
            for(int row=0;row<mrows;row++){ 
                matrices[column][row]=new JTextField();
                matrices[column][row].setText(""+dec.format(matrix[column][row]));
                
                if(column==0 && row==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,1,1,Color.black));
                }else if(column==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,1,0,Color.black));
                }else if(row==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,0,1,Color.black));
                }else{
                    matrices[column][row].setBorder(null);
                }
                if(column==pivotcolumn && row==pivotrow){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(1,1,1,1,Color.red));
                }
                matrices[column][row].setVisible(true);
                matrices[column][row].setColumns(5);
                matrices[column][row].setHorizontalAlignment(javax.swing.JTextField.CENTER);  
                tableaus.add(matrices[column][row]);
            }
        }
        
        /*For BUG FIX*/
        mainframe.setVisible(false);
        mainframe.setVisible(true);
    }
    
    public void display(float[][] matrix){
        /*Add tableaus*/
        DecimalFormat dec=new DecimalFormat("0.00");
        JPanel tableaus=new JPanel();
        tableaus.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        
        JScrollPane scrollers=new JScrollPane();
        scrollers.setViewportView(tableaus);
        computation.add(scrollers, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, view, 302, 139));
        view+=200;
        
        /*Make textfields*/
        tableaus.setLayout(new java.awt.GridLayout(mcolumns, mrows));
        JTextField[][] matrices=new JTextField[mcolumns][mrows];
        
        for(int column=0 ;column<mcolumns;column++){
            for(int row=0;row<mrows;row++){ 
                matrices[column][row]=new JTextField();
                matrices[column][row].setText(""+dec.format(matrix[column][row]));
                if(column==0 && row==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,1,1,Color.black));
                }else if(column==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,1,0,Color.black));
                }else if(row==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,0,1,Color.black));
                }else{
                    matrices[column][row].setBorder(null);
                }
                matrices[column][row].setVisible(true);
                matrices[column][row].setColumns(5);
                matrices[column][row].setHorizontalAlignment(javax.swing.JTextField.CENTER);  
                tableaus.add(matrices[column][row]);
            }
        }
        
        /*For BUG FIX*/
        mainframe.setVisible(false);
        mainframe.setVisible(true);
    }
    
    public void displaysub(float[][] matrix, int subcolumn,int pivotcolumn,int pivotrow){
        
        /*Add tableaus*/
        DecimalFormat dec=new DecimalFormat("0.00");
        JPanel tableaus=new JPanel();
        tableaus.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        
        JScrollPane scrollers=new JScrollPane();
        scrollers.setViewportView(tableaus);
        computation.add(scrollers, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, view, 302, 139));
        view+=200;
        
        /*Make textfields*/
        tableaus.setLayout(new java.awt.GridLayout(mcolumns, mrows));
        JTextField[][] matrices=new JTextField[mcolumns][mrows];
        
        for(int column=0 ;column<mcolumns;column++){
            for(int row=0;row<mrows;row++){ 
                matrices[column][row]=new JTextField();
                matrices[column][row].setText(""+dec.format(matrix[column][row]));
                
                if(column==0 && row==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,1,1,Color.black));
                }else if(column==subcolumn){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(1,1,1,1,Color.black));
                }else if(column==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,1,0,Color.black));
                }else if(row==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,0,1,Color.black));
                }else{
                    matrices[column][row].setBorder(null);
                }
                if(column==pivotcolumn && row==pivotrow){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(1,1,1,1,Color.red));
                }
                matrices[column][row].setVisible(true);
                matrices[column][row].setColumns(5);
                matrices[column][row].setHorizontalAlignment(javax.swing.JTextField.CENTER);  
                tableaus.add(matrices[column][row]);
            }
        }
        
        /*For BUG FIX*/
        mainframe.setVisible(false);
        mainframe.setVisible(true);
    }
    
    public void displaysub(float[][] matrix, int subcolumn){
        /*Add tableaus*/
        DecimalFormat dec=new DecimalFormat("0.00");
        JPanel tableaus=new JPanel();
        tableaus.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        
        JScrollPane scrollers=new JScrollPane();
        scrollers.setViewportView(tableaus);
        computation.add(scrollers, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, view, 302, 139));
        view+=200;
        
        /*Make textfields*/
        tableaus.setLayout(new java.awt.GridLayout(mcolumns, mrows));
        JTextField[][] matrices=new JTextField[mcolumns][mrows];
        
        for(int column=0 ;column<mcolumns;column++){
            for(int row=0;row<mrows;row++){ 
                matrices[column][row]=new JTextField();
                matrices[column][row].setText(""+dec.format(matrix[column][row]));
                if(column==0 && row==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,1,1,Color.black));
                }else if(column==subcolumn){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(1,1,1,1,Color.black));
                }else if(column==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,1,0,Color.black));
                }else if(row==0){
                    matrices[column][row].setBorder(BorderFactory.createMatteBorder(0,0,0,1,Color.black));
                }else{
                    matrices[column][row].setBorder(null);
                }
                matrices[column][row].setVisible(true);
                matrices[column][row].setColumns(5);
                matrices[column][row].setHorizontalAlignment(javax.swing.JTextField.CENTER);  
                tableaus.add(matrices[column][row]);
            }
        }
        
        /*For BUG FIX*/
        mainframe.setVisible(false);
        mainframe.setVisible(true);
    }
    
    public void displaydivide(float[][] matrix,int pivotcolumn,int pivotrow){
        /*Add tableaus*/
        JPanel tableaus=new JPanel();
        tableaus.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        
        JScrollPane scrollers=new JScrollPane();
        scrollers.setViewportView(tableaus);
        computation.add(scrollers, new org.netbeans.lib.awtextra.AbsoluteConstraints(300, view, 150, 139));
        
        tableaus.setLayout(new java.awt.GridLayout(mcolumns, 1));
        JTextField[][] matrices=new JTextField[mcolumns][1];
        
        for(int column=0;column<mcolumns;column++){
            matrices[column][0]=new JTextField();
            if(column!=pivotcolumn){
                matrices[column][0].setText("");
            }else{
                matrices[column][0].setText("1/("+(matrix[pivotcolumn][pivotrow])+")R"+column);
            }
            matrices[column][0].setVisible(true);
            matrices[column][0].setColumns(5);
            matrices[column][0].setHorizontalAlignment(javax.swing.JTextField.CENTER);  
            tableaus.add(matrices[column][0]);
        }
    }
    
    public void displaysubtract(float[][] matrix,int pivotcolumn,int pivotrow){
        /*Add tableaus*/
        JPanel tableaus=new JPanel();
        tableaus.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        
        JScrollPane scrollers=new JScrollPane();
        scrollers.setViewportView(tableaus);
        computation.add(scrollers, new org.netbeans.lib.awtextra.AbsoluteConstraints(300, view, 150, 139));
        
        tableaus.setLayout(new java.awt.GridLayout(mcolumns, 1));
        JTextField[][] matrices=new JTextField[mcolumns][1];
        
        for(int column=0;column<mcolumns;column++){
            matrices[column][0]=new JTextField();
            if(column!=pivotcolumn){
                if(column==0){
                    matrices[column][0].setText("Rz - ("+matrix[column][pivotrow]+")R"+pivotcolumn);
                }else{
                    matrices[column][0].setText("R"+column+" - ("+matrix[column][pivotrow]+")R"+pivotcolumn);
                }
            }else{
                matrices[column][0].setText("");
            }
            matrices[column][0].setVisible(true);
            matrices[column][0].setColumns(5);
            matrices[column][0].setHorizontalAlignment(javax.swing.JTextField.CENTER);  
            tableaus.add(matrices[column][0]);
        }
    }
    
    public void displayFA(float[][] matrix){
        DecimalFormat dec=new DecimalFormat("0.00");
        /*Add tableaus*/
        JPanel tableaus=new JPanel();
        tableaus.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        
        JScrollPane scrollers=new JScrollPane();
        scrollers.setViewportView(tableaus);
        computation.add(scrollers, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, view, 150, 139));
        
        tableaus.setLayout(new java.awt.GridLayout(mrows, 1));
        JTextField[][] matrices=new JTextField[mrows][2];
        /*Optimal Solution*/
        for(int row=0;row<mrows;row++){
            matrices[row][0]=new JTextField();
            if(row!=0){
                int cnt;
                for(cnt=0;cnt<mcolumns-1;cnt++){
                    if(row==FA[cnt]){
                        matrices[row][0].setText(""+dec.format(matrix[FA2[cnt]][0]));
                        break;
                    }
                }
                if(cnt==mcolumns-1){
                    matrices[row][0].setText("0");
                }
            }else{
                matrices[row][0].setText("Xf");
            }
            matrices[row][0].setVisible(true);
            matrices[row][0].setColumns(5);
            matrices[row][0].setHorizontalAlignment(javax.swing.JTextField.CENTER);  
            tableaus.add(matrices[row][0]);
        }
        /*Optimal Answer*/
        tableaus=new JPanel();
        tableaus.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        scrollers=new JScrollPane();
        scrollers.setViewportView(tableaus);
        computation.add(scrollers, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, view+175, 150, 50));
        tableaus.setLayout(new java.awt.GridLayout(1, 2));
        matrices[0][1]=new JTextField();
        matrices[0][1].setText("Z(Xf)");
        matrices[0][1].setVisible(true);
        matrices[0][1].setColumns(5);
        matrices[0][1].setHorizontalAlignment(javax.swing.JTextField.CENTER);  
        tableaus.add(matrices[0][1]);
        matrices[1][1]=new JTextField();
        matrices[1][1].setText(dec.format(matrix[0][0]));
        matrices[1][1].setVisible(true);
        matrices[1][1].setColumns(5);
        matrices[1][1].setHorizontalAlignment(javax.swing.JTextField.CENTER);  
        tableaus.add(matrices[1][1]);
    }
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SubProb.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SubProb.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SubProb.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SubProb.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new index().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField bi;
    private javax.swing.JButton clear;
    private javax.swing.JPanel computation;
    private javax.swing.JButton compute;
    private javax.swing.JTextField ct;
    private javax.swing.JButton generate;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JScrollPane jScrollPane;
    private javax.swing.JPanel mainframe;
    private javax.swing.JScrollPane scroller;
    private javax.swing.JPanel tableau;
    // End of variables declaration//GEN-END:variables
}
